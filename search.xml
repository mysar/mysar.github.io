<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Quartz初步-1]]></title>
      <url>/2017/06/24/Quartz%E5%88%9D%E6%AD%A5-1/</url>
      <content type="html"><![CDATA[<p>前言</p>
<p>之所以需要用到 Quartz，是因为在工作中有一些定时任务，原先在不涉及到多机集群的情况下使用 Java 的 @schedule 注解实现，现在涉及到集群，所以使用 Quartz 代替。</p>
<p>它是一个开源的任务调度框架，基于 Java 的实现。可以用它来实现定时任务，支持集群。</p>
<p>使用 Quartz 会有一些概念：</p>
<p><code>Job</code>：具体需要执行的任务<br><code>JobDetail</code>：该任务的信息，包括具体执行的任务以及其他一些相关的信息<br><code>Trigger</code>：触发器<br><code>Scheduler</code>：任务调度器<br><code>Misfire</code>：错过的，指本来应该被执行但是实际没有被执行的任务调度</p>
<p>实现一个最简单的 Quartz 定时任务（不支持多机），有几个步骤：</p>
<p>创建 Job。<br>创建 JobDetailFactoryBean。顾名思义，可以用于生成 JobDetail 。<br>创建 Trigger。作用：配置定时时间。<br>创建 SchedulerFactoryBean。作用：启动定时任务。<br>实现Demo</p>
<p>创建 Job：具体的执行任务</p>
<pre><code>@Slf4j
public class MyJob implements Job {
    @Override
    public void execute(JobExecutionContext context) throws JobExecutionException {
        log.info(&quot;Do the job!&quot;);
        try {
          log.info(&quot;job scheduler = {}.&quot;,context.getScheduler().getSchedulerName());
    } catch (SchedulerException e) {
        e.printStackTrace();
    }
    log.info(&quot;job trigger = {}.&quot;,context.getTrigger());
}}
</code></pre><p>创建 JobDetailFactoryBean，CronTriggerFactoryBean，SchedulerFactoryBean。</p>
<pre><code>@Slf4j
@Configuration
public class SchedulerJob {

private final static String CRON_EXPRESSION = &quot;*/3 * * * * ?&quot;;

@Bean
public JobDetailFactoryBean createJobDetail(){
    JobDetailFactoryBean jobDetailFactoryBean = new JobDetailFactoryBean();jobDetailFactoryBean.setName(&quot;myJobName&quot;);
    jobDetailFactoryBean.setGroup(&quot;myJobGroup&quot;);

    jobDetailFactoryBean.setJobClass(MyJob.class);

    return jobDetailFactoryBean;
}

@Bean
protected CronTriggerFactoryBean createTrigger(JobDetail jobDetail) {
    CronTriggerFactoryBean cronTriggerFactoryBean = new CronTriggerFactoryBean();
    cronTriggerFactoryBean.setName(&quot;myTriggerName&quot;);
    cronTriggerFactoryBean.setGroup(&quot;myTriggerGroup&quot;);

    cronTriggerFactoryBean.setCronExpression(CRON_EXPRESSION);
    cronTriggerFactoryBean.setJobDetail(jobDetail);
    cronTriggerFactoryBean.setMisfireInstruction(CronTrigger.MISFIRE_INSTRUCTION_IGNORE_MISFIRE_POLICY);

    return cronTriggerFactoryBean;
}

@Bean
public SchedulerFactoryBean schedulerFactoryBean(List&lt;Trigger&gt; triggers){
    SchedulerFactoryBean schedulerFactoryBean = new SchedulerFactoryBean();
    schedulerFactoryBean.setSchedulerName(&quot;myScheduleName&quot;);

    schedulerFactoryBean.setTriggers(triggers.toArray(new Trigger[0]));

    return schedulerFactoryBean;
}
</code></pre><p>以上便可实现一个单机的定时任务。</p>
<p>Quartz 支持多机任务调度原理</p>
<p>Quartz主要是通过 <em>借助关系数据库</em> 和 <em>JDBC作业存储</em> 来实现集群管理的。如下图所示：</p>
<p>quartz</p>
<p>从本质上来说，是使集群上的每一个节点通过共享同一个数据库来工作，并且负载平衡是自动完成的，集群的每个节点会尽快触发任务。当一个触发器的触发时间到达时，第一个节点将会获得任务 <em>（通过锁定）</em> ，成为执行任务的节点。</p>
<p>一个调度器实例在执行涉及到分布式问题的数据库操作前：_首先要获取 QUARTZ<em>LOCKS 表中对应的行级锁</em>，获取锁后即可执行其他表中的数据库操作，随着操作事务的提交，行级锁被释放，供其他调度实例获取。集群中的每一个调度器实例都遵循这样一种严格的操作规程。如下图：<br><img src="https://camo.githubusercontent.com/69771a2cd3fbbc0bab23ac6c754809a645fde4a0/687474703a2f2f3778727a6c6d2e636f6d312e7a302e676c622e636c6f7564646e2e636f6d2f71756172747a2d6c6f636b2d666c6f772e706e67" alt=""></p>
<p>代码实现，还是以上的几个步骤，<em>关键在于SchedulerFactoryBean的创建 和 创建后所设置的属性不同</em>，步骤如下</p>
<p>加入数据库表，在 quartz 包中的 docs -&gt; dbTables 有其数据库表。<br>创建 Job。<br>创建 JobDetailFactoryBean。顾名思义，可以用于生成 JobDetail 。<br>创建 Trigger。作用：配置定时时间。<br>创建 SchedulerFactoryBean。作用：启动定时任务。<br>创建 Job，JobDetail，Trigger 和上述一致，在此不累赘贴出代码。只是 SchedulerFactoryBean 中需要加入 数据源， 并且加入关于集群的配置文件：</p>
<pre><code>@Bean
public SchedulerFactoryBean schedulerFactoryBean(List&lt;Trigger&gt; triggers, DataSource dataSource){
    SchedulerFactoryBean schedulerFactoryBean = new SchedulerFactoryBean();

    schedulerFactoryBean.setTriggers(triggers.toArray(new Trigger[0]));
    schedulerFactoryBean.setQuartzProperties(quartzProperties());
    schedulerFactoryBean.setDataSource(dataSource);

    return schedulerFactoryBean;
}

private Properties quartzProperties(){
    PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
    propertiesFactoryBean.setLocation(new ClassPathResource(&quot;/quartz.properties&quot;));
    try {
        propertiesFactoryBean.afterPropertiesSet();
        return propertiesFactoryBean.getObject();
    } catch (IOException e) {
        log.error(&quot;read quartz.properties file error: {}&quot;, e.getMessage());
    }
    return null;
}
</code></pre><p>如上代码最主要是设置了 factory.setDataSource(dataSource); 和 factory.setQuartzProperties(quartzProperties()); ，在 配置文件 quartz.properties 中，有配置：</p>
<pre><code>org.quartz.scheduler.instanceName = whcClusteredScheduler
org.quartz.scheduler.instanceId = AUTO
org.quartz.threadPool.class = org.quartz.simpl.SimpleThreadPool
org.quartz.threadPool.threadCount = 25
org.quartz.threadPool.threadPriority = 5
org.quartz.jobStore.misfireThreshold = 60000
org.quartz.jobStore.class =   org.springframework.scheduling.quartz.LocalDataSourceJobStore
org.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.StdJDBCDelegate
org.quartz.jobStore.useProperties = true
org.quartz.jobStore.tablePrefix = QRTZ_
org.quartz.jobStore.isClustered = true
org.quartz.jobStore.clusterCheckinInterval = 1000
</code></pre><p>此时，便可实现 Quartz 支持多机，即 Quartz 集群。</p>
<p>具体代码可以参考：点这里</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>拿到了 Trigger，那么 job 就肯定会执行。 首先，在代码中，使用的是乐观锁，服务器不断的轮询，查找需要执行的Trigger。然后，在数据库中，使用的是悲观锁，在查找 Trigger 表之前，需要有权限，也就是需要拿到 QRTZ_LOCKS 表中的对应 Trigegr 的锁，这个实现是也就是行级锁，属于悲观锁。</p>
<p>当某一个机子拿到该锁，然后查询 Trigger 表，执行任务X，修改 Trigger 表中的 NEXT_FIRE_TIME 字段，也就是下次执行的时间字段。这样，当该机子执行ok了之后，别的机子拿到该锁，也查询 Trigger 表，但是由于任务X 的下次执行时间已经修改，所以不会被查找出来。 这样就实现了 多个节点的应用在某一时刻对任务只进行一次调度。</p>
<p>参考<br>表达式例子：</p>
<pre><code>0 * * * * ?    每1分钟触发一次
0 0 * * * ?    每天每1小时触发一次
0 0 10 * * ?   每天10点触发一次
0 * 14 * * ?   在每天下午2点到下午2:59期间的每1分钟触发
0 30 9 1 * ?   每月1号上午9点半
0 15 10 15 * ? 每月15日上午10:15触发

*/5 * * * * ?      每隔5秒执行一次
0 */1 * * * ?      每隔1分钟执行一次
0 0 5-15 * * ?     每天5-15点整点触发
0 0/3 * * * ?      每三分钟触发一次
0 0-5 14 * * ?     在每天下午2点到下午2:05期间的每1分钟触发
0 0/5 14 * * ?     在每天下午2点到下午2:55期间的每5分钟触发
0 0/5 14,18 * * ?  在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发
0 0/30 9-17 * * ?  朝九晚五工作时间内每半小时
0 0 10,14,16 * * ? 每天上午10点，下午2点，4点

0 0 12 ? * WED           表示每个星期三中午12点
0 0 17 ? * TUES,THUR,SAT 每周二、四、六下午五点
0 10,44 14 ? 3 WED       每年三月的星期三的下午2:10和2:44触发
0 15 10 ? * MON-FRI      周一至周五的上午10:15触发

0 0 23 L * ?      每月最后一天23点执行一次
0 15 10 L * ?     每月最后一日的上午10:15触发
0 15 10 ? * 6L    每月的最后一个星期五上午10:15触发

0 15 10 * * ?     2005 2005年的每天上午10:15触发
0 15 10 ? * 6L    2002-2005 2002年至2005年的每月的最后一个星期五上午10:15触发
0 15 10 ? * 6#3   每月的第三个星期五上午10:15触发
</code></pre><p>写在最后</p>
<p>写出来，说出来才知道对不对，知道不对才能改正，改正了才能成长。<br>在技术方面，希望大家眼里都容不得沙子。如果有不对的地方或者需要改进的地方希望可以指出，万分感谢。</p>
]]></content>
      
        <categories>
            
            <category> Quartz </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/06/21/hello-world/</url>
      <content type="html"><![CDATA[<p>你好，世界.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
</search>
