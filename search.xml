<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[CentOS 7.3 x64 环境配置-1]]></title>
      <url>/2017/07/05/CentOS7.3-1/</url>
      <content type="html"><![CDATA[<h2 id="CentOS-7-3-x64-环境配置"><a href="#CentOS-7-3-x64-环境配置" class="headerlink" title="CentOS 7.3 x64 环境配置"></a>CentOS 7.3 x64 环境配置</h2><h3 id="Tomcat配置优化"><a href="#Tomcat配置优化" class="headerlink" title="[Tomcat配置优化]"></a>[Tomcat配置优化]</h3><blockquote>
<ol>
<li>查看端口运行情况  <code>netstat -ntlp</code></li>
<li>通过<code>systemctl start firewalld</code>开启防火墙，没有任何提示即开启成功</li>
<li>修改<code>conf/server.xml</code>8080端口为80</li>
<li>配置防火墙，开放80端口</li>
<li><code>firewall-cmd --zone=public --add-port=80/tcp --permanent</code></li>
<li><code>firewall-cmd --reload</code></li>
</ol>
</blockquote>
<ol>
<li>启动tomcat：  <code>sh /usr/program/tomcat8/bin/startup.sh</code></li>
<li>停止tomcat：  <code>sh /usr/program/tomcat8/bin/shutdown.sh</code></li>
</ol>
<hr>
<p>####1.优化tomcat8：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;!--   针对Tomcat8 80 端口优化--&gt;</div><div class="line">	&lt;Connector executor="tomcatThreadPool"</div><div class="line">			   port="80" </div><div class="line">			   protocol="org.apache.coyote.http11.Http11Nio2Protocol" </div><div class="line">			   connectionTimeout="20000" </div><div class="line">			   maxConnections="10000" </div><div class="line">			   redirectPort="8443" </div><div class="line">			   enableLookups="false"</div><div class="line">			   acceptCount="100" </div><div class="line">			   maxPostSize="10485760" </div><div class="line">			   maxHttpHeaderSize="8192" </div><div class="line">			   compression="on" </div><div class="line">			   disableUploadTimeout="true" </div><div class="line">			   compressionMinSize="2048" </div><div class="line">			   acceptorThreadCount="2" </div><div class="line">compressableMimeType="text/html,text/xml,text/plain,text/css,text/javascript,application/javascript" </div><div class="line">			   URIEncoding="utf-8" /&gt;</div><div class="line">	</div><div class="line">    &lt;!--禁用 AJP（如果你服务器没有使用 Apache）--&gt;</div><div class="line">	&lt;!--  把下面这一行注释掉，默认 Tomcat 是开启的。--&gt;</div><div class="line">	&lt;!--&lt;Connector port="8009" protocol="AJP/1.3" redirectPort="8443" /&gt;--&gt;</div></pre></td></tr></table></figure></p>
<h2 id="Maven配置"><a href="#Maven配置" class="headerlink" title="Maven配置"></a>Maven配置</h2><ol>
<li>下载压缩包：<code>wget http://mirrors.cnnic.cn/apache/maven/maven-3/3.3.9/binaries/apache-maven-3.3.9-bin.tar.gz</code></li>
<li>解压改名：<code>tar zxvf apache-maven-3.3.9-bin.tar.gz</code>  </li>
<li>移到我个人习惯的安装目录下：<code>mv maven3.3.9/ /usr/program</code></li>
<li>环境变量设置：<code>vim /etc/profile</code><br>在文件最尾巴添加下面内容:</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">JAVA_HOME=/usr/program/jdk1<span class="number">.8</span><span class="number">.0</span>_101</div><div class="line">JRE_HOME=$JAVA_HOME/jre</div><div class="line">PATH=$PATH:$JAVA_HOME/bin</div><div class="line">CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</div><div class="line">export JAVA_HOME</div><div class="line">export JRE_HOME</div><div class="line">export PATH</div><div class="line">export CLASSPATH</div><div class="line"></div><div class="line">*Maven*</div><div class="line">MAVEN_HOME=/usr/program/maven3<span class="number">.3</span><span class="number">.9</span></div><div class="line">PATH=$PATH:$MAVEN_HOME/bin</div><div class="line">MAVEN_OPTS=<span class="string">"-Xms256m -Xmx356m"</span></div><div class="line">export MAVEN_HOME</div><div class="line">export PATH</div><div class="line">export MAVEN_OPTS</div></pre></td></tr></table></figure>
<ol>
<li>刷新配置文件：source /etc/profile</li>
<li>测试是否安装成功：mvn -version</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux下常用压缩文件的解压、压缩]]></title>
      <url>/2017/07/03/Linux%E4%B8%8B%E5%B8%B8%E7%94%A8%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E5%8E%8B%E3%80%81%E5%8E%8B%E7%BC%A9/</url>
      <content type="html"><![CDATA[<h1 id="Linux-下常用压缩文件的解压、压缩"><a href="#Linux-下常用压缩文件的解压、压缩" class="headerlink" title="Linux 下常用压缩文件的解压、压缩"></a>Linux 下常用压缩文件的解压、压缩</h1><h2 id="常用压缩包解压命令整理"><a href="#常用压缩包解压命令整理" class="headerlink" title="常用压缩包解压命令整理"></a>常用压缩包<strong>解压</strong>命令整理</h2><ul>
<li>Linux 后缀为 <code>.war</code> 格式的文件（一般用在部署 Tomcat 项目的时候）</li>
<li><p>命令：<code>unzip -oq XXXXXX.war -d ROOT</code></p>
<ul>
<li>如果没有 ROOT 目录会自动创建 ROOT 目录。</li>
</ul>
</li>
<li><p>Linux 后缀为 <code>.tar.gz</code> 格式的文件-解压</p>
</li>
<li><p>命令：<code>tar zxvf XXXXXX.tar.gz</code></p>
</li>
<li><p>Linux 后缀为 <code>.bz2</code> 格式的文件-解压</p>
</li>
<li><p>命令：<code>bzip2 -d XXXXXX.bz2</code></p>
</li>
<li><p>Linux 后缀为 <code>.tar.bz2</code> 格式的文件-解压</p>
</li>
<li><p>命令：<code>tar jxvf XXXXXX.tar.bz2</code></p>
</li>
<li><p>Linux 后缀为 <code>.tar</code> 格式的文件-解压</p>
</li>
<li><p>命令：<code>tar zxvf XXXXXX.tar</code></p>
</li>
<li><p>Linux 后缀为 <code>.gz</code> 格式的文件-解压</p>
</li>
<li><p>命令：<code>gunzip XXXXXX.gz</code></p>
</li>
<li><p>Linux 后缀为 <code>.zip</code> 格式的文件-解压</p>
</li>
<li>命令：<code>unzip XXXXXX.zip</code></li>
<li><p>命令：<code>unzip XXXXXX.zip -d /opt/</code>，解压到指定目录</p>
</li>
<li><p>Linux 后缀为 <code>.7z</code> 格式的文件-解压</p>
</li>
<li><p>命令：<code>7za x XXXXXX.7z</code></p>
</li>
<li><p>Linux 后缀为 <code>.tar.xz</code> 格式的文件-解压，解压出来是tar，再对tar进行解压</p>
</li>
<li>命令：<code>tar xf XXXXXX.tar.xz</code></li>
</ul>
<hr>
<h2 id="常用文件进行压缩命令整理"><a href="#常用文件进行压缩命令整理" class="headerlink" title="常用文件进行压缩命令整理"></a>常用文件进行<strong>压缩</strong>命令整理</h2><ul>
<li>Linux 压缩文件为后缀 <code>.tar</code> 格式的文件</li>
<li><p>命令：<code>tar -zcvf test11.tar test11</code></p>
</li>
<li><p>Linux 压缩文件为后缀 <code>.tar.gz</code> 格式的文件</p>
</li>
<li><p>命令：<code>tar -zcvf test11.tar.gz test11</code></p>
</li>
<li><p>Linux 压缩文件为后缀 <code>.bz2</code> 格式的文件</p>
</li>
<li><p>命令：<code>bzip2 -v test.txt</code></p>
</li>
<li><p>Linux 压缩文件为后缀 <code>.tar.bz2</code> 格式的文件</p>
</li>
<li><p>命令：<code>tar -jcvf test11.tar.gz test11</code></p>
</li>
<li><p>Linux 压缩文件为后缀 <code>.zip</code> 格式的文件</p>
</li>
<li><p>命令：<code>zip -r test1.zip /opt/test1/</code></p>
</li>
<li><p>Linux 压缩文件为后缀 <code>.7z</code> 格式的文件</p>
</li>
<li>命令：<code>7za a test1.7z /opt/test1/</code></li>
</ul>
<h2 id="特殊格式"><a href="#特殊格式" class="headerlink" title="特殊格式"></a>特殊格式</h2><ul>
<li>7z<ul>
<li>7z 的安装：<ul>
<li>访问官网下载解压包：<a href="http://sourceforge.net/projects/p7zip/files/p7zip/" target="_blank" rel="external">http://sourceforge.net/projects/p7zip/files/p7zip/</a></li>
<li>解压压缩包：<code>tar jxvf p7zip_15.14_src_all.tar.bz2</code></li>
<li>进入目录：<code>cd p7zip_15.14</code></li>
<li>执行安装：<code>sh install.sh</code></li>
</ul>
</li>
</ul>
</li>
<li>rar<ul>
<li>rar 的安装：<ul>
<li>下载：<code>wget http://www.rarlab.com/rar/rarlinux-3.8.0.tar.gz</code></li>
<li>解压下载下来的压缩包：<code>tar zxvf rarlinux-3.8.0.tar.gz</code></li>
<li>进入解压后目录：<code>cd rar</code></li>
<li>编译：<code>make</code></li>
<li>安装：<code>make install</code></li>
</ul>
</li>
<li>rar 解压：<code>rar x 文件名.rar</code></li>
</ul>
</li>
</ul>
<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ul>
<li><a href="http://forum.ubuntu.org.cn/viewtopic.php?f=50&amp;t=158893" target="_blank" rel="external">http://forum.ubuntu.org.cn/viewtopic.php?f=50&amp;t=158893</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Quartz初步-1]]></title>
      <url>/2017/06/24/Quartz%E5%88%9D%E6%AD%A5-1/</url>
      <content type="html"><![CDATA[<p>前言</p>
<p>之所以需要用到 Quartz，是因为在工作中有一些定时任务，原先在不涉及到多机集群的情况下使用 Java 的 @schedule 注解实现，现在涉及到集群，所以使用 Quartz 代替。</p>
<p>它是一个开源的任务调度框架，基于 Java 的实现。可以用它来实现定时任务，支持集群。</p>
<p>使用 Quartz 会有一些概念：</p>
<p><code>Job</code>：具体需要执行的任务<br><code>JobDetail</code>：该任务的信息，包括具体执行的任务以及其他一些相关的信息<br><code>Trigger</code>：触发器<br><code>Scheduler</code>：任务调度器<br><code>Misfire</code>：错过的，指本来应该被执行但是实际没有被执行的任务调度</p>
<p>实现一个最简单的 Quartz 定时任务（不支持多机），有几个步骤：</p>
<p>创建 Job。<br>创建 JobDetailFactoryBean。顾名思义，可以用于生成 JobDetail 。<br>创建 Trigger。作用：配置定时时间。<br>创建 SchedulerFactoryBean。作用：启动定时任务。<br>实现Demo</p>
<p>创建 Job：具体的执行任务</p>
<pre><code>@Slf4j
public class MyJob implements Job {
    @Override
    public void execute(JobExecutionContext context) throws JobExecutionException {
        log.info(&quot;Do the job!&quot;);
        try {
          log.info(&quot;job scheduler = {}.&quot;,context.getScheduler().getSchedulerName());
    } catch (SchedulerException e) {
        e.printStackTrace();
    }
    log.info(&quot;job trigger = {}.&quot;,context.getTrigger());
}}
</code></pre><p>创建 JobDetailFactoryBean，CronTriggerFactoryBean，SchedulerFactoryBean。</p>
<pre><code>@Slf4j
@Configuration
public class SchedulerJob {

private final static String CRON_EXPRESSION = &quot;*/3 * * * * ?&quot;;

@Bean
public JobDetailFactoryBean createJobDetail(){
    JobDetailFactoryBean jobDetailFactoryBean = new JobDetailFactoryBean();jobDetailFactoryBean.setName(&quot;myJobName&quot;);
    jobDetailFactoryBean.setGroup(&quot;myJobGroup&quot;);

    jobDetailFactoryBean.setJobClass(MyJob.class);

    return jobDetailFactoryBean;
}

@Bean
protected CronTriggerFactoryBean createTrigger(JobDetail jobDetail) {
    CronTriggerFactoryBean cronTriggerFactoryBean = new CronTriggerFactoryBean();
    cronTriggerFactoryBean.setName(&quot;myTriggerName&quot;);
    cronTriggerFactoryBean.setGroup(&quot;myTriggerGroup&quot;);

    cronTriggerFactoryBean.setCronExpression(CRON_EXPRESSION);
    cronTriggerFactoryBean.setJobDetail(jobDetail);
    cronTriggerFactoryBean.setMisfireInstruction(CronTrigger.MISFIRE_INSTRUCTION_IGNORE_MISFIRE_POLICY);

    return cronTriggerFactoryBean;
}

@Bean
public SchedulerFactoryBean schedulerFactoryBean(List&lt;Trigger&gt; triggers){
    SchedulerFactoryBean schedulerFactoryBean = new SchedulerFactoryBean();
    schedulerFactoryBean.setSchedulerName(&quot;myScheduleName&quot;);

    schedulerFactoryBean.setTriggers(triggers.toArray(new Trigger[0]));

    return schedulerFactoryBean;
}
</code></pre><p>以上便可实现一个单机的定时任务。</p>
<p>Quartz 支持多机任务调度原理</p>
<p>Quartz主要是通过 <em>借助关系数据库</em> 和 <em>JDBC作业存储</em> 来实现集群管理的。如下图所示：</p>
<p>quartz</p>
<p>从本质上来说，是使集群上的每一个节点通过共享同一个数据库来工作，并且负载平衡是自动完成的，集群的每个节点会尽快触发任务。当一个触发器的触发时间到达时，第一个节点将会获得任务 <em>（通过锁定）</em> ，成为执行任务的节点。</p>
<p>一个调度器实例在执行涉及到分布式问题的数据库操作前：_首先要获取 QUARTZ<em>LOCKS 表中对应的行级锁</em>，获取锁后即可执行其他表中的数据库操作，随着操作事务的提交，行级锁被释放，供其他调度实例获取。集群中的每一个调度器实例都遵循这样一种严格的操作规程。如下图：<br><img src="https://camo.githubusercontent.com/69771a2cd3fbbc0bab23ac6c754809a645fde4a0/687474703a2f2f3778727a6c6d2e636f6d312e7a302e676c622e636c6f7564646e2e636f6d2f71756172747a2d6c6f636b2d666c6f772e706e67" alt=""></p>
<p>代码实现，还是以上的几个步骤，<em>关键在于SchedulerFactoryBean的创建 和 创建后所设置的属性不同</em>，步骤如下</p>
<p>加入数据库表，在 quartz 包中的 docs -&gt; dbTables 有其数据库表。<br>创建 Job。<br>创建 JobDetailFactoryBean。顾名思义，可以用于生成 JobDetail 。<br>创建 Trigger。作用：配置定时时间。<br>创建 SchedulerFactoryBean。作用：启动定时任务。<br>创建 Job，JobDetail，Trigger 和上述一致，在此不累赘贴出代码。只是 SchedulerFactoryBean 中需要加入 数据源， 并且加入关于集群的配置文件：</p>
<pre><code>@Bean
public SchedulerFactoryBean schedulerFactoryBean(List&lt;Trigger&gt; triggers, DataSource dataSource){
    SchedulerFactoryBean schedulerFactoryBean = new SchedulerFactoryBean();

    schedulerFactoryBean.setTriggers(triggers.toArray(new Trigger[0]));
    schedulerFactoryBean.setQuartzProperties(quartzProperties());
    schedulerFactoryBean.setDataSource(dataSource);

    return schedulerFactoryBean;
}

private Properties quartzProperties(){
    PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
    propertiesFactoryBean.setLocation(new ClassPathResource(&quot;/quartz.properties&quot;));
    try {
        propertiesFactoryBean.afterPropertiesSet();
        return propertiesFactoryBean.getObject();
    } catch (IOException e) {
        log.error(&quot;read quartz.properties file error: {}&quot;, e.getMessage());
    }
    return null;
}
</code></pre><p>如上代码最主要是设置了 factory.setDataSource(dataSource); 和 factory.setQuartzProperties(quartzProperties()); ，在 配置文件 quartz.properties 中，有配置：</p>
<pre><code>org.quartz.scheduler.instanceName = whcClusteredScheduler
org.quartz.scheduler.instanceId = AUTO
org.quartz.threadPool.class = org.quartz.simpl.SimpleThreadPool
org.quartz.threadPool.threadCount = 25
org.quartz.threadPool.threadPriority = 5
org.quartz.jobStore.misfireThreshold = 60000
org.quartz.jobStore.class =   org.springframework.scheduling.quartz.LocalDataSourceJobStore
org.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.StdJDBCDelegate
org.quartz.jobStore.useProperties = true
org.quartz.jobStore.tablePrefix = QRTZ_
org.quartz.jobStore.isClustered = true
org.quartz.jobStore.clusterCheckinInterval = 1000
</code></pre><p>此时，便可实现 Quartz 支持多机，即 Quartz 集群。</p>
<p>具体代码可以参考：点这里</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>拿到了 Trigger，那么 job 就肯定会执行。 首先，在代码中，使用的是乐观锁，服务器不断的轮询，查找需要执行的Trigger。然后，在数据库中，使用的是悲观锁，在查找 Trigger 表之前，需要有权限，也就是需要拿到 QRTZ_LOCKS 表中的对应 Trigegr 的锁，这个实现是也就是行级锁，属于悲观锁。</p>
<p>当某一个机子拿到该锁，然后查询 Trigger 表，执行任务X，修改 Trigger 表中的 NEXT_FIRE_TIME 字段，也就是下次执行的时间字段。这样，当该机子执行ok了之后，别的机子拿到该锁，也查询 Trigger 表，但是由于任务X 的下次执行时间已经修改，所以不会被查找出来。 这样就实现了 多个节点的应用在某一时刻对任务只进行一次调度。</p>
<p>参考<br>表达式例子：</p>
<pre><code>0 * * * * ?    每1分钟触发一次
0 0 * * * ?    每天每1小时触发一次
0 0 10 * * ?   每天10点触发一次
0 * 14 * * ?   在每天下午2点到下午2:59期间的每1分钟触发
0 30 9 1 * ?   每月1号上午9点半
0 15 10 15 * ? 每月15日上午10:15触发

*/5 * * * * ?      每隔5秒执行一次
0 */1 * * * ?      每隔1分钟执行一次
0 0 5-15 * * ?     每天5-15点整点触发
0 0/3 * * * ?      每三分钟触发一次
0 0-5 14 * * ?     在每天下午2点到下午2:05期间的每1分钟触发
0 0/5 14 * * ?     在每天下午2点到下午2:55期间的每5分钟触发
0 0/5 14,18 * * ?  在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发
0 0/30 9-17 * * ?  朝九晚五工作时间内每半小时
0 0 10,14,16 * * ? 每天上午10点，下午2点，4点

0 0 12 ? * WED           表示每个星期三中午12点
0 0 17 ? * TUES,THUR,SAT 每周二、四、六下午五点
0 10,44 14 ? 3 WED       每年三月的星期三的下午2:10和2:44触发
0 15 10 ? * MON-FRI      周一至周五的上午10:15触发

0 0 23 L * ?      每月最后一天23点执行一次
0 15 10 L * ?     每月最后一日的上午10:15触发
0 15 10 ? * 6L    每月的最后一个星期五上午10:15触发

0 15 10 * * ?     2005 2005年的每天上午10:15触发
0 15 10 ? * 6L    2002-2005 2002年至2005年的每月的最后一个星期五上午10:15触发
0 15 10 ? * 6#3   每月的第三个星期五上午10:15触发
</code></pre><p>写在最后</p>
<p>写出来，说出来才知道对不对，知道不对才能改正，改正了才能成长。<br>在技术方面，希望大家眼里都容不得沙子。如果有不对的地方或者需要改进的地方希望可以指出，万分感谢。</p>
]]></content>
      
        <categories>
            
            <category> Quartz </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/06/21/hello-world/</url>
      <content type="html"><![CDATA[<p>你好，世界！</p>
]]></content>
      
        
    </entry>
    
  
  
</search>
