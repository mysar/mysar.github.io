<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/06/24/hello-world/</url>
      <content type="html"><![CDATA[<p>你好，世界.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Quartz初步-1]]></title>
      <url>/2017/06/21/Quartz%E5%88%9D%E6%AD%A5-1/</url>
      <content type="html"><![CDATA[<p>前言</p>
<p>之所以需要用到 Quartz，是因为在工作中有一些定时任务，原先在不涉及到多机集群的情况下使用 Java 的 @schedule 注解实现，现在涉及到集群，所以使用 Quartz 代替。</p>
<p>Quartz 简介 与 简单Demo（不支持多机）</p>
<p><em>它是一个开源的任务调度框架，基于 Java 的实现。可以用它来实现定时任务，支持集群。</em>使用 Quartz 会有一些概念：</p>
<p>Job：具体需要执行的任务<br>JobDetail：该任务的信息，包括具体执行的任务以及其他一些相关的信息<br>Trigger：触发器<br>Scheduler：任务调度器<br>Misfire：错过的，指本来应该被执行但是实际没有被执行的任务调度<br>实现一个最简单的 Quartz 定时任务（不支持多机），有几个步骤：</p>
<p>创建 Job。<br>创建 JobDetailFactoryBean。顾名思义，可以用于生成 JobDetail 。<br>创建 Trigger。作用：配置定时时间。<br>创建 SchedulerFactoryBean。作用：启动定时任务。<br>实现Demo</p>
<p>创建 Job：具体的执行任务</p>
<p>@Slf4j<br>public class MyJob implements Job {<br>    @Override<br>    public void execute(JobExecutionContext context) throws JobExecutionException {<br>        log.info(“Do the job!”);<br>        try {<br>            log.info(“job scheduler = {}.”,context.getScheduler().getSchedulerName());<br>        } catch (SchedulerException e) {<br>            e.printStackTrace();<br>        }<br>        log.info(“job trigger = {}.”,context.getTrigger());<br>    }<br>}<br>创建 JobDetailFactoryBean，CronTriggerFactoryBean，SchedulerFactoryBean。</p>
<p>@Slf4j<br>@Configuration<br>public class SchedulerJob {</p>
<pre><code>private final static String CRON_EXPRESSION = &quot;*/3 * * * * ?&quot;;

@Bean
public JobDetailFactoryBean createJobDetail(){
    JobDetailFactoryBean jobDetailFactoryBean = new JobDetailFactoryBean();jobDetailFactoryBean.setName(&quot;myJobName&quot;);
    jobDetailFactoryBean.setGroup(&quot;myJobGroup&quot;);

    jobDetailFactoryBean.setJobClass(MyJob.class);

    return jobDetailFactoryBean;
}

@Bean
protected CronTriggerFactoryBean createTrigger(JobDetail jobDetail) {
    CronTriggerFactoryBean cronTriggerFactoryBean = new CronTriggerFactoryBean();
    cronTriggerFactoryBean.setName(&quot;myTriggerName&quot;);
    cronTriggerFactoryBean.setGroup(&quot;myTriggerGroup&quot;);

    cronTriggerFactoryBean.setCronExpression(CRON_EXPRESSION);
    cronTriggerFactoryBean.setJobDetail(jobDetail);
    cronTriggerFactoryBean.setMisfireInstruction(CronTrigger.MISFIRE_INSTRUCTION_IGNORE_MISFIRE_POLICY);

    return cronTriggerFactoryBean;
}

@Bean
public SchedulerFactoryBean schedulerFactoryBean(List&lt;Trigger&gt; triggers){
    SchedulerFactoryBean schedulerFactoryBean = new SchedulerFactoryBean();
    schedulerFactoryBean.setSchedulerName(&quot;myScheduleName&quot;);

    schedulerFactoryBean.setTriggers(triggers.toArray(new Trigger[0]));

    return schedulerFactoryBean;
}
</code></pre><p>}<br>以上便可实现一个单机的定时任务。</p>
<p>Quartz 支持多机任务调度原理</p>
<p>Quartz主要是通过 <em>借助关系数据库</em> 和 <em>JDBC作业存储</em> 来实现集群管理的。如下图所示：</p>
<p>quartz</p>
<p>从本质上来说，是使集群上的每一个节点通过共享同一个数据库来工作，并且负载平衡是自动完成的，集群的每个节点会尽快触发任务。当一个触发器的触发时间到达时，第一个节点将会获得任务 <em>（通过锁定）</em> ，成为执行任务的节点。</p>
<p>一个调度器实例在执行涉及到分布式问题的数据库操作前：_首先要获取 QUARTZ<em>LOCKS 表中对应的行级锁</em>，获取锁后即可执行其他表中的数据库操作，随着操作事务的提交，行级锁被释放，供其他调度实例获取。集群中的每一个调度器实例都遵循这样一种严格的操作规程。如下图：<br><img src="https://camo.githubusercontent.com/69771a2cd3fbbc0bab23ac6c754809a645fde4a0/687474703a2f2f3778727a6c6d2e636f6d312e7a302e676c622e636c6f7564646e2e636f6d2f71756172747a2d6c6f636b2d666c6f772e706e67" alt=""></p>
<p>代码实现，还是以上的几个步骤，<em>关键在于SchedulerFactoryBean的创建 和 创建后所设置的属性不同</em>，步骤如下</p>
<p>加入数据库表，在 quartz 包中的 docs -&gt; dbTables 有其数据库表。<br>创建 Job。<br>创建 JobDetailFactoryBean。顾名思义，可以用于生成 JobDetail 。<br>创建 Trigger。作用：配置定时时间。<br>创建 SchedulerFactoryBean。作用：启动定时任务。<br>创建 Job，JobDetail，Trigger 和上述一致，在此不累赘贴出代码。只是 SchedulerFactoryBean 中需要加入 数据源， 并且加入关于集群的配置文件：</p>
<pre><code>@Bean
public SchedulerFactoryBean schedulerFactoryBean(List&lt;Trigger&gt; triggers, DataSource dataSource){
    SchedulerFactoryBean schedulerFactoryBean = new SchedulerFactoryBean();

    schedulerFactoryBean.setTriggers(triggers.toArray(new Trigger[0]));
    schedulerFactoryBean.setQuartzProperties(quartzProperties());
    schedulerFactoryBean.setDataSource(dataSource);

    return schedulerFactoryBean;
}

private Properties quartzProperties(){
    PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
    propertiesFactoryBean.setLocation(new ClassPathResource(&quot;/quartz.properties&quot;));
    try {
        propertiesFactoryBean.afterPropertiesSet();
        return propertiesFactoryBean.getObject();
    } catch (IOException e) {
        log.error(&quot;read quartz.properties file error: {}&quot;, e.getMessage());
    }
    return null;
}
</code></pre><p>如上代码最主要是设置了 factory.setDataSource(dataSource); 和 factory.setQuartzProperties(quartzProperties()); ，在 配置文件 quartz.properties 中，有配置：</p>
<pre><code>org.quartz.scheduler.instanceName = whcClusteredScheduler
org.quartz.scheduler.instanceId = AUTO
org.quartz.threadPool.class = org.quartz.simpl.SimpleThreadPool
org.quartz.threadPool.threadCount = 25
org.quartz.threadPool.threadPriority = 5
org.quartz.jobStore.misfireThreshold = 60000
org.quartz.jobStore.class =   org.springframework.scheduling.quartz.LocalDataSourceJobStore
org.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.StdJDBCDelegate
org.quartz.jobStore.useProperties = true
org.quartz.jobStore.tablePrefix = QRTZ_
org.quartz.jobStore.isClustered = true
org.quartz.jobStore.clusterCheckinInterval = 1000
</code></pre><p>此时，便可实现 Quartz 支持多机，即 Quartz 集群。</p>
<p>具体代码可以参考：点这里</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>拿到了 Trigger，那么 job 就肯定会执行。 首先，在代码中，使用的是乐观锁，服务器不断的轮询，查找需要执行的Trigger。然后，在数据库中，使用的是悲观锁，在查找 Trigger 表之前，需要有权限，也就是需要拿到 QRTZ_LOCKS 表中的对应 Trigegr 的锁，这个实现是也就是行级锁，属于悲观锁。</p>
<p>当某一个机子拿到该锁，然后查询 Trigger 表，执行任务X，修改 Trigger 表中的 NEXT_FIRE_TIME 字段，也就是下次执行的时间字段。这样，当该机子执行ok了之后，别的机子拿到该锁，也查询 Trigger 表，但是由于任务X 的下次执行时间已经修改，所以不会被查找出来。 这样就实现了 多个节点的应用在某一时刻对任务只进行一次调度。</p>
<p>参考</p>
<p>官网 Quick Start<br>官网 Configure Clustering with JDBC-JobStore<br>写在最后</p>
<p>写出来，说出来才知道对不对，知道不对才能改正，改正了才能成长。<br>在技术方面，希望大家眼里都容不得沙子。如果有不对的地方或者需要改进的地方希望可以指出，万分感谢。</p>
]]></content>
      
        
    </entry>
    
  
  
</search>
